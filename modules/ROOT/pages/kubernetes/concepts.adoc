= Concepts

== Networking

=== SDN

Software Defined Network (SDN) routes the traffic across a virtualized system.
It is a broad concept that does not belong to Kubernetes (unlike CNI).

Kubernetes through the notion of network plugins can be use with a vast number of SDN. The most famous are:

- Calico (L3) used by GKE, EKS, AKS, ...
- OpenShiftSDN
- ACI plugin for Kubernetes
- Flannel (can run in L2)

=== CNI

Kubernetes Networking has one important fundamental design property:

====
Every Pod must be able to communicate with each other in the cluster without
NAT, using a unique IP.
====

This means pods (unlike dockers) communicates likes VMs where the receiving side sees this unique IP.
Containers inside a pod share the same network namespace and communicate over localhost.

This network scheme is not implemented by Kubernetes but via a plugin architecture called the Container Network Interface (#CNI#) model.

=== Isolation

By default, pods are non-isolated; they accept traffic from any source.
Pods become isolated through `NetworkPolicy` that are implemented by a network plugin that supports this feature..

=== Services

Expose a single, constant IP address through which clients can connect to a set of pods.
Services operate at the transport layer (TCP/IP).

Each service receives a unique virtual IP called #ClusterIP# that has not visibility outside of the cluster.
This is the job of the `kube-proxy` that is installed on every node and is achieved through iptables or other means according to the type of the `kube-proxy` in use.
`ClusterIP` is also the default type of a service. To make the service available to the external world, you need to use/specify another type of service such as `NodePort`, `LoadBalancer` or `ExternalName`.

```
kind: Service
apiVersion: v1
metadata:
  name: my-service
spec:
  selector:
    app: MyApp
  ports:
  - protocol: TCP
    port: 80
    targetPort: 9376
  type: ClusterIP <1>
```
<1> NodePort | LoadBalancer | ExternalName

A NodePort service is the most primitive way to get external traffic directly to your service. NodePort opens a specific port on all the nodes, and any traffic that is sent to this port is forwarded to the service.

=== Ingress

Each LoadBalancer service requires its own load balancer with its own public IP address. Ingress only requires one, even when providing access to dozens of services. Ingresses operate at the application layer (HTTP).


== Persistent Volume

*PV* is an object representing storage. It is independent of any single pod and doesn't belong to any namespace (alike node).

*PVC* results in a mapping of a PV to a pod (within a namespace).
The request PV will be bind-mounted to the container itself

```
kind: PersistentVolumeClaim
apiVersion: v1
metadata:
  name: thisclaim
spec:
  accessModes:
    - ReadWriteOnce <1>
  resources:
    requests:
      storage: 8Gi

```
<1> “ReadWriteOnce” tells Kubernetes that this storage can only be mounted by a single container host in read-write mode
In contrast “ReadWriteMany” tells Kubernetes that the storage can be mounted from multiple containers on different hosts.


=== Static provisioning

With static provisioning, PVs are created beforehand by an administrator and expected to match a future claim.

=== Dynamic provisioning

Provider -*StorageClass*- knows how to provision storage on-the fly when a request comes in.

```
apiVersion: storage.k8s.io/v1
kind: StorageClass
metadata:
  name: fast
provisioner: kubernetes.io/glusterfs
parameters:
  resturl: "http://127.0.0.1:8081"
  restauthenabled: "true"
  restuser: "admin"
  secretNamespace: "default"
  secretName: "heketi-secret"

```
PVCs referring to that particular storage class will get their PV objects created on-demand in a completely transparent fashion.

=== Storage plugin/class choices

“ReadWriteMany” is not supported by all storages. Currently GCE Persistent Disk / AWS EBS / AzureDisk don't support it.
These might have performance issues on small capacities (<100GB, typical for PVCs)

OpenEBS:: (relies on iSCSI)


== Auto-Scaling

:Todo:

== Probes

Liveness::
Detect if a container becomes unresponsive (need to be restarted)

Readiness::
Detect if a ready to start accepting traffic.

See https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-probes/[Probe configuration]
