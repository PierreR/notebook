= Programming Notes


== Notion

Functional Programming::

The meaning of the programs is centered around evaluating expressions rather than executing instructions.

""
This is the key to functional programming’s power — it allows improved modularization

In a functional program what is important is that it is a value oriented language; what we are building are sentences made from different values and higher order functions. The types and higher order values are defining the grammar of those sentences.
""

Algebraic Data Type::

A struct or new type, composed from other types either as a product or a sum type.

|=====
| Name | Member | Inhabitant

| Void | | 0
| Unit | () | 1
| Bool | True, False | 2
|=====

Going from there you can define by sum a type with 3 elements:
```haskell
data Add a b = AddL a | AddR b
-- or
data Either a b = Left a | Right b

-- if a is Bool and b is () you have got:
addValues = [AddL False, AddL True, AddR ()]

```

You can also use a product type with Mul:

```haskell
data Mul a b = Mul a b
-- or
data (,) a b = (a, b)

mulValues = [Mul False False, Mul False True, Mul True False, Mul True True]

```

Abstract Data Type (ADT)::

A data type is said to be abstract when its implementation is hidden from the client.
ADT's are types which encapsulates a set of operations.
The concept originates from CLU (Liskov, 1972) :

> Modules -> Partitions -> ADTs

The canonical example is a `Stack` for which we define a set of operations including a way to construct/get a new empty Stack.

This is very different and even dual to the concept of objects in OO. ADT operations belongs to its datatype whereas OO objects are implemented as collections of observations (methods) that can be performed upon them. The focus on observations, rather than construction, means that objects are best understood as co-algebras.

Hash Value::

`Hashing` is a transformation `AnyText -> TextWithFixedSmallerSize` (array of bites) called `digest` or `hash value` with the following (ideal) properties:

- it is quick to compute
- it is not reversible: you cannot get anyText from the digest
- the `digest` is unique so that two different `AnyText` will always have a different digest.


The idea is to store this mapping in a database so that you use `digest` as a representation for `AnyText` (the `digest` becomes the id/handle for the Text).
Given such a mapping you can also hash `AnyText`, get a `digest` and do a lookup in the table to see if the mapping already exists.

CAP::

- Consistency
- Availability
- Partition


Glossary::
+
.nibble
Half of one byte. So 4 bits/digits -> 16 values
+
.subroutine
Synonym for function
+
.subtype
....
Circle <: Shape
....
+
.Object Orientated Programming
Objects by definition include mutable state -> intensional object identity !!


== Quotes

Monitoring::

""
Software should be designed from the start to be monitored
""

ORM::

""
ORMs are mixing different concerns. There were introduced by OO zealots to avoid the declarative nature of SQL. Now according to Martin Fowler they are just a way to get memory cache. Yes right but that is not the way ORMs have been sold ?

The whole ORM story looks like a complete disaster. Building a graph of objects in memory across sessions has proven to make little sense in many projects I had worked on.

If you deal with a relational database, abstracting it with mutable pojos is dubious at best. I am pretty convinced a nice API query interface such as LINQ can solve the problems of the myriads of SQL statements to handle.

Here is the problem, at the end, data are used to be feed into viewer. So let's get this straight. Output JSON directly from a query language interface !
""

== Scrible


Please do understand the difference between -> and => ... what you need here is "lead to" maybe implies

RAM : Heap & Stack

IDENDITY LABEL FOR A TIMELINE
CONFLATE ID WITH STATE
REF TYPE BOXES TO VALUES

How do we express polymorphism in UML. You mark class with a stereotype. You have to see class as something really global in UML. It is just a blueprint of code.
