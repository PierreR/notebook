# Exception in Haskell
Pierre Radermecker <pierrer@pi3r.be>
2016
:language: haskell
:source-highlighter: pygments
:icons: font

## Exception

We have three different types of exceptions.

Fully synchronous exceptions:: generated as a result of an action failing somehow (same thread) e.g. throwIO

Fully asynchronous exceptions:: generated when another thread or the runtime system is trying to kill the current thread (via throwTo) or report an unrecoverable footnote:[I'm not sure "unrecoverable" is strictly true here to be honest] situation like a StackOverflow

Interrupts:: falls into an in-between category. They are like synchronous exceptions, in that they can only be thrown as the result of an interruptible IO action occurring (as opposed to fully asynchronous exceptions, which can occur anywhere, including pure code evaluation). But they are like asynchronous exceptions too, in that they are generated by something outside of the current thread. footnote:[Though, in the case of deadlock detection, you could argue that misusing an MVar or TVar "caused" the interrupt to get thrown]

So to once again see where we all agree: there is no way to have a cleanup function run reliably if fully async exceptions can be thrown to it, since there is no way for the cleanup function to guarantee it will perform the cleanup before such an async exception is thrown. 

At the opposite end, with fully synchronous exceptions, there is nothing that bracket can do to help: it is fully the responsibility of the cleanup function itself to ensure that it behaves correctly in the presence of a self-generated synchronous exception. (If there is disagreement up until this point, please say so!)

So we're once again left with the interrupt case falling in the middle. I think we all agree that it's technically possible for a cleanup function to be written correctly with interrupts turn on (i.e., using mask and not uninterruptibleMask). The minimal proof for this is that the cleanup function could always be wrapped itself in uninterruptibleMask_, which gives no weaker guarantees than if bracket used it[3]. But if we're going to require all cleanup functions to just wrap themselves in uninterruptibleMask_ anyway, why not just have bracket do it!

I'm going to take a leap for a moment, and say that the real crux of the matter is a slightly orthogonal question: do we need to assume that all IO action may throw an exception at all times? I believe that @Peaker is arguing that, given the correct masking state and upon careful analysis of the actions being used, we can guarantee that some IO actions will not fail, and therefore it is safe in a cleanup function to simply chain such actions together (e.g., foo >> bar). @Yuras seems to be arguing that we should assume that all IO actions may throw an exception (whether synchronous or an interrupt), and therefore an expression like foo >> bar should never be trusted to guarantee bar will be run. If such a guarantee is needed, then it should always be written as foo `finally` bar.

I won't weigh in with my opinion just yet, I'd really like to make sure I'm understanding the nuances of this discussion before forming an opinion.
