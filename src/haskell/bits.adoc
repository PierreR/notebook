= Bits
Pierre Radermecker <pierrer@pi3r.be>
2014-2016
:toc: left
:toclevels: 1
:imagesdir: img
:data-uri:
:source-language: haskell
:source-highlighter: pygments
:icons: font
:keywords: haskell
:numbered:
:sectnumlevels: 1
:nofooter:

> This is the key to functional programming’s power — it allows improved modularization

> In a functional program what is important is that it is a value oriented language; what we are building are sentences made from different values and higher order functions. The types and higher order values are defining the grammar of those sentences.

> Software should be designed from the start to be monitored

== Functional Programming
 * The meaning of the programs is centered around evaluating expressions rather than executing instructions.

== Operator colloquial name

|=======
| >>=  |   bind           |
| >>   |   then           |
| *>   |   then           |
| ->   |   to             |  a -> b: a to b
| <-   |   bind           |  (as it desugars to >>=)
| <$>  |   (f)map         |
| <$   |   map-replace by |  0 <$ f: "f map-replace by 0"
| <*>  |   ap(ply)        |
| $    |   apply to or of |
| .    |   after          |  a . b $ c: "a after b applied to c"
| !!   |   index          |
| !    |   index, strict  | a ! b: "a index b", foo !x: foo strict x
| <\|> |   or, appbin     | expr <\|> term: "expr or term"
| ++   |   append         |
| []   |   empty list     |
| :    |   cons           |
| ::   |   of type        |  f x :: Int: f x of type Int
| \    |   lambda         |
| @    |   as             |  go ll@(l:ls): go ll as l cons ls
| ~    |   lazy           |  go ~(a,b): go lazy pair a, b
| >\=> |   fish           |
| \<=< |   left fish      |
|=======

== Lazyness

Reduction is done using outermost reduction. For instance:
```
loop = tail loop

fst (1, loop)
-- innermost reduction gives:
-- fst (1, (tail loop))
-- fst (1, (tail (tail loop))) and never terminates
-- but outermost reduction gives:
-- fst (1, loop) = 1 and terminates
```

=== Redex
```
-- only one redex (2*3) both innermost and outermost
1 + (2 * 3)

-- 2 redexes :
-- (\x -> 1 + x ) (2 * 3) outermost
-- (2 * 3) innermost
(\x -> 1 + x ) (2 * 3)

```

== MonadPlus

Two operations:

* `mzero`, zero value or failure
* `mplus`, combine two computations

```
msum = foldr mplus mzero
```

In a list, a monadplus will give you the first successful computation or the last zero value. With failures, it really disregards them finding for a success:
```
[Just 1, Just 2, Nothing]              -> Just 1
[Left "Failing", Right()]              -> Right ()
[Left "Failing", Left "Failing again"] -> Left "Failing again"
msum [Left "F", Right "R"]             -> Right "R"
```
Note that some monad such as ExceptT are appending (using the monoid instance) the error messages (the `Monoid m => Left m`)  when using `asum` or `msum`.

In 7.10, every MonadPlus are `Alternative` (likewise all monads are applicative).
In that spirit you should avoid using `mzero` and `mplus` if possible; replacing them with empty and (<|>).

[WARNING]

====
 `(++)` needs to reconstruct the list on the left !
 So this is not efficient [1..10000] ++ [4]

====

== Existential classes

> When someone defines a universal type ∀X they're saying: You can plug in whatever type you want, I don't need to know anything about the type to do my job, I'll only refer to it opaquely as X.

> When someone defines an existential type ∃X they're saying: I'll use whatever type I want here; you wont know anything about the type, so you can only refer to it opaquely as X

== Type class

Type class enables a (de)limited form of `adhoc polymorphism` or `overloading`.
Each instance implements the same function differently or to say it diffently one function will behave diffently according to the types of its arguments.

The `adhoc polymporphism` needs to be delimited as such to play well with `parametric polymorphism` and keeping the type checking sane.

Type class are not first class in Haskell. They cannot be used in place of type (as you would in Java with interface).

It is *dictionnary passing*: Ghc puts the methods of the instance in a dictionary and passes that implicitly to any functions having a (Class a) constraint.

It is best to look at them as a set of constraints on type.
One notable drawback is that each type can have at most one implementation of the type class.

`Eq` is the classical example.

In Scala, type-classes are types themselves, and instances are first class values.

== Type Family

```
data Nat = Zero | Succ Nat

-- Add is a type which is a function on types
type family Add (x :: Nat) (y :: Nat) :: Nat
-- Then comes the implementation of the (type) function
type instance Add Zero     y = y
type instance Add (Succ x) y = Succ (Add x y)

```

== Determinic parallel programming

A set of states with an order attached to it is known as a lattice

== Ref/State Primitives

StateT::
The State monad is commonly used when needing state in a single thread of control.
It doesn't actually use mutable state and so does not necessary operate in IO.
Instead, the program is parameterized by the state value.
StateT frequently gets used to hold program configuration data, or "game-world-state" types of state in applications.

MVars::
concurrency primitive, designed for access from multiple threads.
It is a box which can be full or empty. If a thread tries to read a value from an empty MVar, it will block until the MVar gets filled (by another thread). Same with full and takeMVar.

IVar::
Immutable variable you are only allowed to write to it once.

STM::
Retry aborts the transaction and retry it whenever the TVar gets modified.

IORef::
Just a reference to some data, a `cell`.
Operate in IO.
You can think of it like a database, file, or other external data store.
`atomicModifyIORef` uses CAS (compare and swap implemented at the hardware level) to guarantee the atomicity of read-modify-write kind of operations.

ST::
Like IO but with just the power of mutate. You can also escape from it. The main data structure in ST is the STRef, which is like an IORef but with a different monad.
The ST monad uses type system trickery (the "state threads" the docs mention) to ensure that mutable data can't escape the monad; that is, when you run an ST computation you get a pure result.
The reason ST is interesting is that it's a primitive monad like IO, allowing computations to perform low-level manipulations on bytearrays and pointers.
This means that ST can provide a pure interface while using low-level operations on mutable data, meaning it's very fast. From the perspective of the program, it's as if the ST computation runs in a separate thread with thread-local storage.


== ByteString

* Word8 is Haskell's standard representation of a byte
* ByeString character functions (`Data.ByteString.Char8`) only work with ASCII text, hence the Char8 in the package name
  -> if you are working with unicode, you should use the Text package
* In general we use strict bytestring when you have control about the message. Lazy bytestring is a bit more flexible and used for streaming.

https://www.fpcomplete.com/school/pick-of-the-week/bytestring-bits-and-pieces?show=tutorials[FP tutorial]

== FreeT

The fixed point of a function is generally just the repeated application of that function:

```
fix f = f (f (f (f (f (f (f (f (f (f (f (f (f ... ))))))))))))
-- or
fix f = f (fix f)
```

```
data Free f a = Free (f (Free f a)) | Pure a
```

== UI

* HsQML (qt 5)
* SDL2/gl for game
* Web (ghcjs, threepenny, ...)



== Q ?

== Mind blowing

```
instance Monoid r => Monoid (Managed r) where
    mempty = pure mempty
    mappend = liftA2 mappend
```

```
xs = 1 : [x + 1 | x <- xs] --> [1,2,3 ...]
```

```
Right cfg -> return . Right . query cfg fp =<< F.newFileCache
```

== Useful

`-fdefer-type-errors`

== Common functions

```
-- give a default and always get an a from a maybe value
maybe:: a -> Maybe a -> a
```