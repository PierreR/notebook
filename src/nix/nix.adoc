= Nix
Pierre Radermecker <pierrer@pi3r.be>
2014-2016
:toc: left
:toclevels: 1
:source-language: bash
:source-highlighter: pygments
:icons: font
:keywords: nix, nixos 
:numbered:
:sectnumlevels: 1
:nofooter:

== NixOS

=== icon:tasks[] Install

. switch to azerty keyboard
+
```
→ loadkeys be-latin1
```
. partition with gdisk (efi) or fdisk (noefi)
+
icon:info-circle[] using virtualbox you don't want/need efi
+
```
→ (g/f)disk /dev/sda
```
+
create 2 partitions sda1(83 default)/sda2(82)
. create file system
+
```
→ mkfs.extmre4 -L nixos /dev/sda1
→ mkswap -L swap /dev/sda2
```
. mount it
+
```
→ mount /dev/disk/by-label/nixos /mnt
```
. generate a default config
+
`→ nixos-generate-config --root /mnt`
. minimal edit the config; don't forget to uncomment the option 'boot.loader.grub.device'
+
```
→ nano /mnt/etc/nixos/configuration.nix
```
. Install
+
`→ nixos-install
. reboot
+
```
→ reboot
```
. upgrade
+
```
→ nixos-rebuild boot --upgrade
→ reboot
```
. tweak config
+
.. install neovim, gitFull, htop, ...
.. create a new user icon:exclamation-circle[] +
(root won't be able to have a chromium session by default)
.. use the `NetworkManager` text user interface 'nmtui' to configure wireless

=== icon:cog[] System management

.Update
```
→ sudo nixos-rebuild switch
→ sudo nixos-rebuild boot --upgrade <1>
```
<1> safer to use `boot` when upgrading

== Derivation

In nix, packages are called derivations. Derivations are stored in the nix store as follows: /nix/store/hash-name, where the hash uniquely identifies the derivation (not true, it's a little more complex than this), and name is the name of the derivation.

From a nix language point of view, a derivation is simply a set, with some attributes.

To build a package, `nixpkgs` makes heavy usage of `stdenv` and its function `mkDerivation`:

```nix
stdenv.mkDerivation {
  name = "libfoo-${version}"; <1>
  version = "1.2.3"
  src = fetchurl {
    url = http://example.org/libfoo-1.2.3.tar.bz2;
    md5 = "e1ec107956b6ddcb0b8b0679367e9ac9";
  };
  builder = ./builder.sh; <2>
  buildInputs = [ruby]; <3>
}
```
<1> mandatory `name` attr
<2> if not provided, the generic builder is used
<3> additional requirement needed to build the derivation

====
drv files:: specification of how to build a derivation similar to the `.o` file in C.
====

== Channels

A channel is the Nix mechanism for distributing a consistent set of Nix expressions and binaries.
nix-channel --add 

```
→ nix-channel --add http://nixos.org/channels/nixpkgs-unstable
→ nix-channel --update
→ nixos-rebuild switch
```

== Nix-shell

When Nix builds a package, it builds it in an isolated environment. It does this by creating a clean, child shell, then adding only the dependencies the package declares. After setting up the dependencies, it runs the build script, moves the built app into the Nix store, and sets up the environment to point to it. Finally, it destroys this child shell.

But we can ask Nix to not destroy the child shell, and instead let us use it for working iteratively on the app. This is what the `nix-shell` is about:

```
 nix-shell '<nixpkgs>' -A nvi -p ruby
```

If a path is not given, nix-shell defaults to `shell.nix` if it exists, and `default.nix` otherwise. This allows for a nice trick. We can decribe a virtual dev environment (of any sort for any language) by decribing a derivation in `default.nix` like so:

.default.nix
```nix
with import <nixpkgs> {};

let henv = haskellPackages.ghcWithPackages (p: with p; [shake]);

in
stdenv.mkDerivation {
  name = "haskell-env";
  buildInputs = [ henv pythonPackages.pyyaml];
}
```
[NOTE]
====
In Haskell, we can use https://github.com/NixOS/nixpkgs/blob/b40e1efe000ec5c4616cecc9d6836eade419434e/pkgs/development/haskell-modules/generic-builder.nix#L283[env] to build the isolated environment:

.shell.nix
```nix
with (import <nixpkgs> {}).pkgs;
(haskellPackages.callPackage ./. {}).env <1>
```
<1> `callPackage` will use the current defined scope to pass matched arguments

`default.nix` is then generated by `cabal2nix` to describe how to nix-build the haskell package.
====

You can force any script file to run in a nix-shell as such:
```
#! /usr/bin/env nix-shell
#! nix-shell -i bash 
```
or without a default.nix file:

```
#! /usr/bin/env nix-shell
#! nix-shell -i bash -p pythonPackages.pyyaml -p '(import <nixpkgs> {}).haskellPackages.ghcWithPackages (p: with p; [shake])'
```
== Commands

nix-env::
- *-q* list installed derivations within a profile
- *-qaP* list available package with the path
[WARNING]
====
The Haskell package set is not registered in the top-level namespace because it is huge. As a consequence, when searching for haskell  packages you need to provide the `haskellPackages` attribute:
```
→ nix-env -f '<nixpkgs>' -qaP -A haskellPackages.shake <1>
# In nixos, you can also do:
→ nix-env -qaP -A nixos.pythonPackages
```
<1> together with `-A`, `-f` needs to be provided.
====
- *-i* install derivations
+
```
→ nix-env -f "<nixpkgs>" -iA pythonPackages.pyyaml
→ nix-env -e python2.7-PyYAML-3.11
```
- *-u* update
+
```
→ nix-env -u '*'
```
nix-build:: 
+
```
```

== Language Expressions

Set::
+
```nix
let x = 123; in
{ inherit x; <1>
  text = "Hello";
  y = f { bla = 456; };
}.text or "World" <2>
```
<1> When defining a set it is often convenient to copy variables from the surrounding lexical scope
<2> Sets accessor using `.` +
    Default using `or`

List::
+
```nix
[ 123 ./foo.nix "abc" (f { x = y; }) ]
```

Function::
+
```nix
pattern: body
```
+
```nix
negate = x: !x; <1>
```
<1> pattern is a single identifier 'x'
+
```nix
{stdenv, fetchurl, perl }: <1>

  stdenv.mkDerivation { <2>
    name = "hello-2.1.1";
	...
  };
```
<1> pattern is a set of arguments
<2> function call

With::
+
```nix
with e1; e2
```
Introduces all attributes of the set `e1` into the lexical scope of the expression `e2`:
+
```nix
let as = { x = "foo"; y = "bar"; };
in with as; x + y
```

Optional argument::
+
```nix
{ x, y ? "foo", z ? "bar" }: z + y + x <1>
```
<1> a function that only requires an attribute named x, but optionally accepts y and z.

Merge sets::
+
```nix
e1 // e2 # merge e1 and e2 with e2 taking precedence in case of equally named attribute
```

== Idioms

Override pkgs derivations::
+
```nix
pkgs.overridePackages (self: super: {
  foo = super.foo.override { barSupport = true ; };
})
```
[WARNING]
====
In `~/.nixpkgs/config.nix` you typically declare a `packageOverrides` function knowing it will be called to customize <nixpkgs> locally

.~/.nixpkgs/config.nix
```nix
{
  packageOverrides = super:
    let self = super.pkgs;
    in {
      haskellPackages = super.haskellPackages.override {
      ...
      };
}
```
====

Override pattern::
+
```nix
fix = f:
  let self = f self;
  in self;

extend = attrs: f: self:
  let super = attrs self;
  in super // f self super;

ps = self:
  { foo = "foo"; bar = "bar";
     foobar = self.foo + self.bar;
  };

f = self: super:
  { foo = reverse super.foo; }

(fix ps).foobar # "foobar"

(fix (extend ps f)).foobar # "oofbar"
```

== Bootstrap

Nix composes all of these individual functions into a large package repository. This repository essentially calls every single top level function, with support for recursive bindings in order to satisfy dependencies. Continuing with the hello example, we may have a top-level entry point like:


```nix
rec {
  hello = import /path/to/hello.nix { inherit stdenv fetchurl; }; <1>

  stdenv = import /path/to/stdenv.nix { inherit gcc };

  fetchurl = import /path/to ;

  gcc = import /path/to/gcc.nix {};

  # ...
}
```
<1> Import loads a file containing a function and then calls that function with the provided arguments

> But wait - I just said this calls all functions… so wouldn’t that then mean that all software gets installed? The trick here is that Nix is a lazy language.


== Ruby

* Create or copy a Gemfile at the root dir of the project
* Install bundler in my user profile if it is not already there.
* Create a Gemfile.lock by running bundler lock
* Use bundix in the target directory: $(nix-build '<nixpkgs>' -A bundix)/bin/bundix. It will create a gimset.nix file
* Create a default.nix file

== References

- http://lethalman.blogspot.be/search/label/nixpills[nix pills]