= Category
Pierre Radermecker <pierrer@pi3r.be>
2014
:language: haskell
:source-highlighter: pygments
:icons: font

== Category Theory

> Abstract algebra of function
> In category theory we never look inside objects. All information about objects is encoded in the arrows (morphisms) between them.

definition::

A category is a bunch of objects (that exist objectively) together with `morphisms`.
Morphisms are mappings between these objects that preverse a `structure`.
The structure whatever it is characterizes the category.

* there must exist a morphism called `identity` (the zero) that maps an object into itself (e.g: 1A).
* the morphisms need to compose while respecting `associativity`: +
  `h∘(g∘f) == (h∘g)∘f`

.Example:
The category of `Set` where functions are morphisms and the objects set `f: A -> B`

== Functor

> A functor is a structure-preserving mapping (or homomorphism) between 2 categories.

This means that :

* for an object `A` in one category, there is a corresponding object `F A` in the second one.
* for a morphism (A -> B), there is the corresponding F A -> F B

In Haskell, the objects are types and the mappings are functions. Type constructors (* -> *) are used to map types into types.

```
class Functor f where
	fmap :: (a -> b) -> f a -> f b
```

The functor defines the action of an arbitrary function (a -> b) on a structure (f a) of elements of type a resulting in the same structure but full of elements of type b.

.Laws:
```
fmap id = id
fmap (g . h) = fmap g . fmap h
```
.Example:
```
instance Functor ((->) r) where
  fmap f g = f . g -- or fmap = (.)
```

Another intuition is to look at functors as producers of output that can have its type adapted. So `Maybe a` represents an output of type a that might be present (Just a) or absent (Nothing). `fmap f` allows us to adapt the output of type a to an output of type b.

Whenever you have producer of outputs, you might also have the dual consumer of inputs. This is where Contravariant comes in. The intuition behind a Contravariant is that it reflects a sort of "consumer of input" that can have the type of accepted input adapted.

```
class Contravariant f where
  contramap :: (b -> a) -> f a -> f b
```

So here we can adapt the *input* to go from a consumer of input 'a' to a consumer of input 'b'. But to go there you need to provide a function from 'b' to 'a'


== Isomorphisms

Category theory allows us to give a precise, abstract (works for all categories) and self-contained definition of an isomorphism:

An arrow/morphism f: A -> B is called an isomorphism in *C* if there is an arrow g that goes from B to A such that: +
g ∘ f = 1A and f ∘ g = 1B

== Applicative

With a functor f it is not possible to apply a function wrapped by the structure `f` to a value wrapped by f. This is given by Applicative:

```
class Functor f ⇒ Applicative f where
  pure :: a → f a
 (<*>) :: f (a → b) → f a → f b
```
(<*>) is just function application within a computational context.

As soon as you want to define the type `(a -> b -> c) -> f a -> f b -> f c` you need the applicative construction:

```
liftA2 :: Applicative f => (a -> b -> c) -> f a -> f b -> f c
liftA2 f a b = fmap f a <*> b
```
It is not that hard to convince yourself that an applicative functor is just a functor that knows how to lift functions of arbitrary arities.

.Laws:
----
fmap g x = pure g <*> x
----

Applicative functors are to be preferred to monads when the structure of a computation is fixed a priori.
That makes it possible to perform certain kinds of static analysis on applicative values.

=== Alternative

An Alternative instance gives an applicative functor the structure of a monoid,
with empty as the unit element, and <|> as the binary operation. 

```
class Applicative f ⇒ Alternative f where
  empty :: f a
 (<|>) :: f a → f a → f a
```

== Monad

```
class Applicative m => Monad m where
  join :: m (m a) -> m a

(>>=) :: m a -> (a -> m b) -> m b <1>
```
<1> The signature of `bind` allows the second computation to depend on the value of the first one.

> Monadic values are produced in a context. Monads provide both substitution (fmap) and renormalization (join). 
```
m >>= f = join (fmap f m)
```

Even if a monad is strictly more powerful than an Applicative, there are situations for which an applicative is the only valid choice.
Indeed `<*>` lets you explore both arguments by pattern matching but with `ap` the right hand side cannot be evaluated without the result from the left.

As a stretch while applicative allows for parallelism, monad allows for sequencing.

> A monad is like a monoid where we combine functors "vertically". `join` is analogous to `(+)` and `return` to `0`.

NOTE: By law `>>` = `*>`. Consequently `mapM_` =  `traverse_`.

- Side-Effect
- Environment
- Error
- Indeterminism

== Free

A free construction is a real instance of that construction that hold no extra property. It is the least special possible instance.
A free monad is just substitution (fmap) with the minimum amount of renormalization needed to pass the monad laws.

It is perfect to separate syntax (data, ast, parsing) from semantics (interpretation)

> The free monad is guaranteed to be the formulation that gives you the most flexibility how to interpret it, since it is purely syntactic.

```
data Free f a = Pure a | Free (f (Free f a))
```

The fixed point of a function is generally just the repeated application of that function:
fix f = f (f (f (f (f (f (f (f (f (f (f (f (f ... ))))))))))))
or
fix f = f (fix f)
